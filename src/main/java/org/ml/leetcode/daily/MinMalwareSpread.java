package org.ml.leetcode.daily;

import java.util.*;

/**
 * 给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。
 * 在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j。
 *
 * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，
 * 且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
 * 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 *
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 *
 * 如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
 *
 * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。
 *
 *
 *
 * 示例 1：
 *
 * 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * 输出：0
 * 示例 2：
 *
 * 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * 输出：0
 * 示例 3：
 *
 * 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * 输出：1
 *
 *
 * 提示：
 *
 * n == graph.length
 * n == graph[i].length
 * 2 <= n <= 300
 * graph[i][j] == 0 或 1.
 * graph[i][j] == graph[j][i]
 * graph[i][i] == 1
 * 1 <= initial.length <= n
 * 0 <= initial[i] <= n - 1
 * initial 中所有整数均不重复
 *
 *
 * 并查集～～～
 * 直接使用 set 的并查在set合并时会超时
 * 使用 map + 树的方式，在进行遍历时不断缩短树的高度来尽量缩短时间复杂度
 */
public class MinMalwareSpread {
    public static void main(String[] args) {
        int[][] graph = new int[][]{
                new int[]{1,0,0,0},
                new int[]{0,1,0,0},
                new int[]{0,0,1,1},
        new int[]{0,0,1,1}};//,new int[]{0,0,1,1,0,0,0},new int[]{0,1,1,0,1,1,0},new int[]{0,0,1,0,1,1,0},new int[]{0,0,0,0,0,0,1}};
        int[] initial = new int[]{3,1};
        new MinMalwareSpread().minMalwareSpread1(graph, initial);
    }

    static class NodeSet {
        Set<Integer> set;

        int initial = 0;

        public NodeSet() {
            this.set = new HashSet<>();
        }

        public boolean contain(int val) {
            return set.contains(val);
        }

        public void add(int val) {
            set.add(val);
        }

        public void merge(NodeSet inSet) {
            set.addAll(inSet.set);
        }

        public void addInitial(int val){
            initial ++;
        }
    }
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Map<Integer, NodeSet> map = new HashMap<>();
        int n = graph.length;
        for(int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                NodeSet iSet = map.get(i);
                NodeSet jSet = map.get(j);
                if (graph[i][j] == 1) {
                    NodeSet set;
                    if (iSet == null && jSet == null) {
                        set = new NodeSet();

                    } else if (iSet == null || jSet == null) {
                        set = iSet == null ? jSet : iSet;

                    } else {
                        iSet.merge(jSet);
                        set = iSet;
                        for(int val : jSet.set) {
                            map.put(val, iSet);
                        }
                    }
                    set.add(i);
                    set.add(j);
                    map.put(i, set);
                    map.put(j, set);
                } else {
                    if (iSet == null) {
                        NodeSet set = new NodeSet();
                        set.add(i);
                        map.put(i, set);
                    }
                    if (jSet == null) {
                        NodeSet set = new NodeSet();
                        set.add(j);
                        map.put(j, set);
                    }
                }
            }
        }
        for (int initVal : initial) {
            map.get(initVal).addInitial(initVal);
        }

        int maxClear = 0;
        int minMaxClearIdx = Integer.MAX_VALUE;

        for (int val : initial) {
            NodeSet set = map.get(val);
            if (set.initial > 1) {
                if (maxClear == 0) minMaxClearIdx = Math.min(minMaxClearIdx, val);
            } else {
                int currentClear = set.set.size();
                if (maxClear < currentClear) {
                    maxClear = currentClear;
                    minMaxClearIdx = val;
                } else if (maxClear == currentClear) {
                    minMaxClearIdx = Math.min(minMaxClearIdx, val);
                }
            }
        }
        return minMaxClearIdx;
    }

    static class N {
        int val;

        public N(int val) {
            this.val = val;
            this.count = 0;
            this.initialCount = 0;
        }
        
        boolean record = false;

        int count;
        int initialCount;


        @Override
        public int hashCode() {
            return Objects.hash(val);
        }
    }

    Map<N, N> map = new HashMap<>();
    N[] nods = new N[0];

    public int minMalwareSpread1(int[][] graph, int[] initial) {
        int n = graph.length;
        nods = new N[n];
        for (int i = 0; i < n; i++) {
            nods[i] = new N(i);
        }

        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                if (graph[i][j] == 1 || graph[j][i] == 1) {
                    addNode(i, j);
                }
            }
        }

        for (int i = 0; i < n; i++) {
            N nod = nods[i];
            count(nod);
        }

        for (int j : initial) {
            N nod = nods[j];
            updateInitialCnt(nod);
        }

        int maxClear = 0;
        int minMaxClearIdx = Integer.MAX_VALUE;
        for (int j : initial) {
            N nod = nods[j];
            N root = getRoot(nod);
            if(root.initialCount > 1){
                if (maxClear == 0) {
                    minMaxClearIdx = Math.min(minMaxClearIdx, j);
                }
            } else {
                int tmpCount = maxClear;
                if (root.count > maxClear) {
                    tmpCount = root.count;
                }else if (root.count == maxClear) {
                    minMaxClearIdx = Math.min(j, minMaxClearIdx);
                }
                if (tmpCount != maxClear) {
                    minMaxClearIdx = j;
                }
                maxClear = tmpCount;
            }
        }
        return minMaxClearIdx;
    }
    
    

    public void addNode(int val1, int val2) {
        N nod1 = nods[val1];
        N nod2 = nods[val2];
        N n1 = map.get(nod1);
        N n2 = map.get(nod2);
        if (n1 == null && n2 == null) {
            n1 = nod1;
            n2 = nod2;
            map.put(n1, n1);
            map.put(n2, n1);
        } else if(n1 == null || n2 == null) {
            N inMap = n1 == null ? nod2 : nod1;
            N notInMap = n1 == null ? nod1 : nod2;
            N root = getRoot(inMap);
            map.put(notInMap, root);
        } else {
            N root1 = getRoot(nod1);
            N root2 = getRoot(nod2);
            map.put(root2, root1);
        }

    }

    private void updateInitialCnt(N nod) {
        N p = getRoot(nod);
        p.initialCount++;
    }
    
    private N count(N nod) {
        N p = map.get(nod);
        if (p == null) {
            nod.count = 1;
            map.put(nod, nod);
            return nod;
        }

        if (p == nod) {
            p.count += 1;
            return p;
        }
        p = count(p);
        map.put(nod, p);
        return p;
    }
    
    private N getRoot(N nod){
        N p = map.get(nod);
        if (nod == p) return nod;
        N root = getRoot(p);
        map.put(nod, root);
        return root;
    }

}
